# API 약속 정리

## Case 1: 새로운 배송지 직접 입력

- **프론트엔드 역할**:
  - 사용자가 입력한 배송지 정보를 `delivery_info` 객체에 담아 전송.
- **백엔드 기대 동작**:
  - `use_default_address: false`를 확인하고, 함께 전달된 `delivery_info` 객체를 배송지 정보로 사용.

### JSON 예시

```json
{
  "delivery_info": {
    "recipient": "선물받는사람",
    "address": "서울시 강남구",
    "phone": "010-5678-1234"
  },
  "cart_item_ids": [3],
  "use_default_address": false
}
```

---

## Case 2: 주문자 정보와 동일 (기본 배송지 사용)

- **프론트엔드 역할**:
  - `delivery_info` 객체를 보내지 않고, `use_default_address` 플래그를 `true`로 설정하여 전송.
- **백엔드 기대 동작**:
  - `use_default_address: true`를 확인한 뒤, `delivery_info`가 없는 것을 확인하고, DB에서 현재 로그인한 사용자의 기본 주소 정보를 조회하여 배송지로 사용.

### JSON 예시

```json
{
  "cart_item_ids": [3],
  "use_default_address": true
}
```

---

## 설계 의도

- 두 가지 경우를 명확히 구분하여 API를 설계.
- **프론트엔드**:
  - UI 상태에 따라 전송 데이터를 조절.
- **백엔드**:
  - 플래그 값에 따라 유연하게 비즈니스 로직 처리.

이 약속은 프론트엔드 개발을 시작하기 위한 명확한 가이드라인이 됩니다.

# 주요 변경 사항 상세 분석

## 1. 보안 강화: "내 장바구니 상품만 주문"하도록 강제

가장 중요하고 핵심적인 변경 사항입니다.

### 이전 방식의 문제점

- `order.repository.js`의 `create` 함수는 `cart_item_ids` 배열만 받아서 `SELECT ... FROM carts WHERE id IN (?)` 쿼리를 실행했습니다.
- 만약 악의적인 사용자가 다른 사람의 장바구니 ID(예: `cart_item_id=100`)를 추측하여 자신의 주문 요청에 포함시키면, 다른 사람의 장바구니에 있는 상품을 자신의 주문으로 포함시킬 수 있는 심각한 보안 허점이 있었습니다.

### 개선된 방식의 해결책

- 새로운 `findCartItemsForOrder` 함수는 `userId`를 함께 받아, `WHERE c.user_id = ? AND c.id IN (?)` 쿼리를 실행합니다.
- "현재 로그인한 사용자의 장바구니에 있으면서, 요청된 ID 목록에 포함된" 상품만 조회하도록 강제합니다.
- `items.length !== cartItemIds.length` 비교를 통해, 요청된 모든 상품 ID가 사용자의 소유인지 검증합니다.
  - 하나라도 일치하지 않으면, 다른 사람의 장바구니 ID를 포함시킨 것으로 간주하고 에러를 발생시켜 주문 절차를 중단합니다.

```javascript
// [개선된 부분] user_id로 소유권 검증
const sql = `
  SELECT c.book_id, c.quantity, b.price
  FROM carts c
  JOIN books b ON c.book_id = b.id
  WHERE c.user_id = ? AND c.id IN (?)`; // <-- user_id 조건 추가
```

---

## 2. 책임과 역할의 명확한 분리 (관심사 분리)

코드를 각 계층(Controller, Service, Repository)의 역할에 맞게 더 명확하게 분리했습니다.

### Controller (요청 처리 및 검증 담당)

- **역할**: HTTP 요청을 받아, 입력값의 유효성(Validation)을 책임지는 "문지기" 역할.
- **변경점**:
  - `cart_item_ids`가 비어있는지, `delivery_info`가 누락되었는지 등을 검사하는 로직을 컨트롤러로 이동.
  - 서비스 계층에 필요한 모든 정보, 즉 `req.user` 객체 전체(`currentUser`)를 전달.

### Service (비즈니스 로직 담당)

- **역할**: "어떤 비즈니스 로직을 수행할지 결정하는 조정자" 역할.
- **변경점**:
  - 이전에는 `userRepository`를 직접 호출하여 사용자 정보를 가져왔으나, 이제 컨트롤러로부터 `currentUser` 객체를 전달받아 사용.
  - `order.service.js`가 `user` 도메인의 데이터베이스 접근 방식에 대해 알 필요가 없어짐.
  - 의존성이 제거되어 코드가 더 깔끔해지고 테스트하기 쉬워짐.

### Repository (데이터베이스 통신 담당)

- **역할**: "데이터베이스와 통신하는 유일한 창구" 역할.
- **변경점**:
  - 하나의 거대한 `create` 함수를 `findCartItemsForOrder`, `insertOrderDetails`와 같은 더 작고 명확한 역할의 함수들로 분리.
  - 코드의 가독성과 재사용성이 크게 향상됨.

---

## 3. 안정성 및 코드 품질 향상

### 안정적인 에러 처리

- 컨트롤러에서 입력값을 미리 검증하여, 잘못된 요청이 서비스나 레파지토리 계층까지 도달하여 예기치 않은 오류를 유발하지 않도록 방지.
- `new Error(...)` 대신, 상태 코드를 포함하는 `CustomError`를 사용하여 API 응답의 신뢰성을 개선.

### 가독성 높은 코드 구조

- `order.repository.js`의 `create` 함수는 이제 5단계의 주석으로 설명된 것처럼, "어떤 순서로 함수를 호출하는지"에 대한 흐름만 보여줌.
- 각 단계의 구체적인 SQL 쿼리나 데이터 처리 방식은 분리된 작은 함수들 내부에 캡슐화되어, 전체 로직을 쉽게 파악할 수 있음.

---

## 실행 흐름 비교 요약

| **구분**         | **이전 방식의 흐름**                                  | **개선된 방식의 흐름**                                                               |
| ---------------- | ----------------------------------------------------- | ------------------------------------------------------------------------------------ |
| **1. 요청 처리** | 컨트롤러가 요청을 받아 서비스로 단순 전달             | 컨트롤러가 입력값 유효성을 먼저 검증하고, `req.user` 정보를 포함하여 서비스에 전달   |
| **2. 주소 처리** | 서비스가 `userRepository`를 호출하여 DB에서 주소 조회 | 서비스가 전달받은 `currentUser` 객체를 사용하여 주소 정보 구성 (DB 접근 불필요)      |
| **3. 주문 생성** | 하나의 거대한 `create` 함수에서 모든 DB 작업 수행     | 여러 개의 작은 함수(`findCartItems...`, `insert...`)를 순차적으로 호출하며 작업 수행 |
| **4. 보안 검증** | 없음 (다른 사람의 장바구니 상품 주문 가능)            | `findCartItemsForOrder` 함수 내에서 `user_id`로 소유권 철저히 검증                   |

---

## 결론

이번 개선을 통해 코드는 단순히 기능만 동작하는 것을 넘어:

1. **더욱 안전**하고,
2. **구조적으로 명확**하며,
3. **유지보수하기 쉬운 코드**로 발전했습니다.

# API 서버 기능 개선 및 오류 해결 보고서

**작성자**: JHParrrk
**작성일**: 2025-10-22

## 1. 개요

본 문서는 온라인 서점 프로젝트의 API 서버를 개발하는 과정에서 발생한 주요 오류들을 진단하고 해결한 과정을 기록한 것이다. 초기 기능 구현 후 "주문자 정보와 동일" 기능을 추가하는 과정에서 발생한 **`404 Not Found` 오류**, **데이터 누락 오류**, 그리고 **데이터베이스 저장 오류**를 순차적으로 해결하며 코드의 안정성과 구조적 완성도를 높이는 것을 목표로 하였다.

---

## 2. 문제 해결 과정

### 가. 문제 상황 1: `POST /orders` 요청의 `404 Not Found` 오류

#### 1) 증상

`GET /orders/:orderId`와 같은 다른 API는 정상적으로 동작하였으나, 유독 주문 생성 API인 `POST /orders` 요청만 `404 Not Found` 에러를 반환하였다.

#### 2) 원인 진단

`404` 에러는 일반적으로 라우팅 경로를 찾지 못했을 때 발생한다. `routes/orders.js` 파일에는 `POST /` 경로가 명확히 정의되어 있었으므로, 문제는 라우터 자체가 아닌 Express 애플리케이션의 미들웨어 설정에 있을 것으로 추정했다. `app.js` 파일을 분석한 결과, **에러 처리 미들웨어(`errorHandler`)가 라우터 설정보다 앞에 위치**하여, 요청이 라우터에 도달하기 전에 잘못 처리되고 있음을 발견했다.

#### 3) 해결 방안

Express에서 에러 처리 미들웨어는 반드시 모든 라우터 설정이 끝난 후, 가장 마지막에 위치해야 한다. `app.js`에서 `app.use(errorHandler);`의 위치를 모든 `app.use('/...', router)` 설정의 뒤로 이동시켜 미들웨어 실행 순서를 바로잡았다.

```javascript
// app.js (수정 후)

// ... 라우터 설정 ...
app.use("/orders", ordersRouter);
// ...

// catch 404 and forward to error handler
app.use(function (req, res, next) {
  next(createError(404));
});

// error handler - 모든 요청 처리의 가장 마지막에 위치해야 한다.
app.use(errorHandler);
```

### 나. 문제 상황 2: "기본 배송지로 설정된 주소가 없습니다." 오류

#### 1) 증상

`404` 오류 해결 후, "주문자 정보와 동일" 옵션(`use_default_address: true`)을 사용하여 주문을 시도하자, 서버에서 `req.user` 객체에 주소 정보가 없다며 오류를 반환했다.

#### 2) 원인 진단

`authenticateJWT` 미들웨어에서 `console.log(req.user)`를 통해 확인한 결과, JWT 토큰을 디코딩한 객체에 `id`와 `email`만 포함되어 있고, 주문 로직에 필요한 `name`, `address`, `phone_number`가 누락되어 있었다. 이는 **사용자 로그인 시 JWT 토큰을 생성하는 단계**에서 `payload`에 최소한의 정보만 담았기 때문이었다.

#### 3) 해결 방안

`user.controller.js`의 `login` 함수에서 토큰 생성 로직을 수정했다. `userService.login`으로부터 받은, 모든 정보가 담긴 `user` 객체 전체를 `generateAccessToken` 함수에 전달하도록 변경했다. 이로써 JWT 페이로드에 필요한 모든 사용자 정보가 포함되도록 보장했다.

```javascript
// user.controller.js (수정 후)

exports.login = async (req, res, next) => {
  // ...
  const user = await userService.login(email, password);

  // user 객체 전체를 전달하여 모든 정보가 토큰에 담기도록 수정
  const accessToken = generateAccessToken(user);
  const refreshToken = generateRefreshToken(user);
  // ...
};
```

### 다. 문제 상황 3: "Data too long for column 'token'" 데이터베이스 오류

#### 1) 증상

JWT 페이로드 문제를 해결하고 다시 로그인을 시도하자, 데이터베이스에서 "Data too long" 오류가 발생하며 로그인이 실패했다.

#### 2) 원인 진단

JWT 토큰에 더 많은 정보를 담게 되면서, 생성된 토큰 문자열의 길이가 이전보다 길어졌다. 데이터베이스의 `refresh_tokens` 테이블에 정의된 `token` 컬럼의 타입이 `VARCHAR(255)`로 설정되어 있어, 길어진 리프레시 토큰을 저장하기에 크기가 부족했던 것이다.

#### 3) 해결 방안

데이터베이스 스키마를 직접 수정하여 컬럼의 크기를 늘렸다. 가변적인 길이의 JWT를 안전하게 저장하기 위해, `VARCHAR` 대신 최대 65,535자까지 저장할 수 있는 **`TEXT`** 타입으로 변경했다.

```sql
-- SQL 수정 명령
ALTER TABLE `refresh_tokens` MODIFY COLUMN `token` TEXT NOT NULL;
```

---

## 3. 결론 및 추가 개선 사항

일련의 디버깅 과정을 통해 초기 기능 구현 시 발생했던 세 가지 주요 오류를 모두 해결했다. 이 과정에서 단순히 오류를 수정하는 것을 넘어, 다음과 같은 구조적 개선도 함께 이루어졌다.

- **보안 강화**: 주문 생성 로직에 **장바구니 상품의 소유권을 검증**하는 로직을 추가하여, 다른 사용자의 상품을 주문할 수 있는 잠재적 보안 허점을 차단했다.
- **코드 구조 개선**: 레파지토리의 복잡한 함수를 단일 책임 원칙에 따라 여러 개의 작은 함수로 분리하여 코드의 가독성과 유지보수성을 향상시켰다.
- **계층 간 책임 명확화**: 컨트롤러는 입력값 검증, 서비스는 비즈니스 로직 조정, 레파지토리는 데이터 접근이라는 각 계층의 책임을 더욱 명확히 하여 코드의 응집도를 높였다.

이번 경험을 통해 기능 구현뿐만 아니라, 미들웨어의 동작 원리, 데이터 흐름의 일관성, 그리고 데이터베이스 스키마 설계의 중요성을 깊이 이해하게 되었다.
